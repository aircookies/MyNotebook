# CSS学习笔记

CSS是层叠样式表(Cascading Style Sheets)的简称.
有时我们也会称之为**CSS样式表**或**级联样式表**.
CSS也是一种标记语言.
CSS主要用于设置HTML页面中的**文本内容**(字体,大小,对齐方式等),**图片的外形**(宽高,边框样式,边距等)以及**版面的布局和外观显示样式**.

1. HTML主要做结构,显示元素内容.
2. CSS美化HTML,布局网页.
3. CSS最大的价值:由HTML专注去做结构呈现,样式交给CSS,即结构(HTML)与样式(CSS)相分离.

## CSS语法规范

使用HTML时,需要遵从一定的规范,CSS也是如此.要想熟练地使用CSS对网页进行修饰,首先需要了解CSS样式规则.

**CSS规则由两个主要的部分构成:选择器以及一条或多条声明.**

``` css
h1 { color:red; font-size:25px; }
```

- **选择器**是用于指定CSS样式的**HTML标签**,花括号内是该对象设置的具体样式.
- 属性和属性值以"键值对"的形式出现
- 属性是对指定的对象设置样式属性,例如字体大小,文本颜色等
- 属性和属性值之间用英文":"分开
- 多个"键值对"之间用英文";"进行区分

## CSS代码风格

样式格式书写:

紧凑格式

``` css
h3 { color: blue; font-size: 20px; }
```

展开格式

``` css
h3 {
    color: pink;
    font-size: 20px;
}
```

空格规范:

``` css
h3 {
    color: pink;
}
```

- 属性值前面,冒号后面,保留一个空格.
- 选择器(标签)和大括号中间保留空格.

## 选择器分类

**选择器**分为**基础选择器**和**复合选择器**两个大类

- 基础选择器是由**单个选择器**组成的
- 基础选择器又包括:**标签选择器,类选择器,id选择器和通配符选择器**

### 标签选择器

标签选择器(元素选择器)是指用**HTML标签名称**作为选择器,按标签名称分类,为页面中某一类标签指定统一的CSS样式.

语法:

``` css
标签名 {
    属性1: 属性值1;
    属性2: 属性值2;
    属性3: 属性值3;
    ...
}
```

### 类选择器

如果想要差异化选择不同的标签,单独选一个或者某几个标签,可以使用**类选择器**.
类选择器在HTML中以**class**属性表示,在CSS中,类选择器以一个点"."号表示.

**语法:**

``` css
.类名 {
    属性1: 属性值1;
    ...
}
```

例如,将所有拥有red类的HTML元素均为红色.

``` css
.red {
    color: red;
}
```

结构需要用**class属性**来调用class类的意思

``` html
<div class='red'> 变红色 </div>
```

**注意:**

1. 类选择器使用"."(英文点号)进行标识,后面紧跟类名(自定义,我们自己命名的).
2. 可以理解为给这个标签起了一个名字,来表示.
3. 长名词或词组可以使用横杠来为选择器命名.
4. 不要使用纯数字,中文等命名,尽量使用英文字符来表示.
5. 命名要有意义,尽量使别人一眼就能知道这个类名的目的.

#### 多类名

我们可以给一个标签指定**多个类名**,从而达到更多的选择目的.这些类名都可以选出这个标签.
简单理解就是一个标签有多个名字.

多类名使用方式:

``` html
<div class="red font20">亚瑟</div>
```

1. 在标签class属性中写多个类名.
2. 多个类名中间必须用空格分开.

### id选择器

id选择器可以为标有特定id的HTML元素指定特定的样式.
HTML元素以**id属性**来设置id选择器,CSS中id选择器以"**#**"来定义.

**语法:**

``` css
#id名 {
    属性1: 属性值1;
    ...
}
```

例如,将id为nav元素中的内容设置为红色.

``` css
#nav {
    color: red;
}
```

**注意:id属性只能在每个HTML文档中出现一次.**

### 通配符选择器

在CSS中,通配符选择器使用"*"定义,它表示选取页面中的所有元素(标签).

**语法:**

``` css
* {
    属性1: 属性值1;
    ...
}
```

- 通配符选择器不需要调用,自动就给所有的元素使用样式

### 基础选择器总结

| 基础选择器 | 作用 | 特点 | 使用情况 | 用法 |
| --- | --- | --- | --- | --- |
| 标签选择器 | 可以选出所有相同的标签,比如p | 不能差异化选择 | 较多 | p { color: red; } |
| 类选择器 | 可以选出1个或多个标签 | 可以根据需求选择 | 非常多 | .nav { color: red; } |
| id选择器 | 一次只能选择1个标签 | ID属性只能在每个HTML文档中出现一次 | 一般和js搭配使用 | #nav { color: red; } |
| 通配符选择器 | 选择所有的标签 | 选择的太多,有部分不需要 | 特殊情况使用 | * { color: red; } |

---

## CSS字体属性

CSS Font(字体)属性用于定义**字体系列**,大小,粗细,和文字样式(如斜体).

### 字体系列

CSS使用**font-family**属性定义文本的字体系列.

``` css
p {
    font-family: "微软雅黑";
}

div {
    font-family: Arial, "Microsoft Yahei", "微软雅黑";
}
```

- 各种字体之间必须使用英文逗号隔开.
- 一般情况下,如果有空格隔开的多个单词组成的字体,加引号.
- 尽量使用系统默认自带字体,保证在任何用户的浏览器中都能正确显示.

### 字体大小

CSS使用**font-size**属性定义字体大小.

``` css
p {
    font-size: 20px;
}
```

- px(像素)大小是网页的最常用单位
- 谷歌浏览器默认的文字大小为16px
- 不同的浏览器可能默认显示的字号大小不一致,应尽量给一个明确值大小,不要默认大小
- 可以给body指定整个页面的文字的大小

### 字体粗细

CSS使用**font-weight**属性设置文本字体的粗细.

``` css
p {
    font-weight: bold;
}
```

| 属性值 | 描述 |
| --- | --- |
| normal | 默认值(不加粗细的) |
| bold | 定义粗体(加粗的) |
| 100~900 | 400等同于normal,而700等同于bold(注意数字后面不跟单位) |

### 文字样式

CSS使用**font-style**属性设置文本的风格.

``` css
p {
    font-style: normal;
}
```

| 属性值 | 作用 |
| --- | --- |
| normal | 默认值,浏览器会显示标准的字体样式 font-style:normal; |
| italic | 浏览器会显示斜体的字体样式. |

### 字体复合属性

字体属性可以把以上文字样式综合来写,这样可以更节省代码:

``` css
body {
    font: font-style font-weight font-size/line-height font-family;
}
```

- 使用font属性时,必须按照上面的语法格式的顺序书写,**不能更换顺序**,并且各个属性之间以**空格**隔开
- 不需要设置的属性可以省略(取默认值),但**必须保留font-size和font-family属性**,否则font属性将不起作用

| 属性 | 表示 | 注意点 |
| --- | --- | --- |
| font-size | 字号 | 我们通常用的单位是px(像素),一定要跟上单位 |
| font-family | 字体 | 实际工作中按照团队约定来写字体 |
| font-weight | 字体粗细 | 记住加粗是700或者bold,不加粗是normal或者400记住数字不要跟单位 |
| font-style | 字体样式 | 记住倾斜是italic,不倾斜是normal,工作中常用normal |
| font | 字体连写 | 字体连写是有顺序的,不能随意换位置,其中字号和字体必须同时出现 |

---

## CSS文本属性

CSS Text(文本)属性可定义文本的**外观**,比如文本的颜色,对齐文本,装饰文本,文本缩进,行间距等.

### 文本颜色

**color**属性用于定义文本的颜色.

``` css
div {
    color: red;
}
```

| 表示 | 属性值 |
| --- | --- |
| 预定义的颜色值 | red, green, blue |
| 十六进制 | #FF0000, #FF6600, #29D794 |
| RGB代码 | rgb(255, 0, 0)或rgb(100%, 0%, 0%) |

**开发中最常用的是十六进制.**

### 对齐文本

**text-align**属性用于设置元素内文本内容的水平对齐方式.

``` css
div {
    text-align: center;
}
```

| 属性值 | 解释 |
| --- | --- |
| left | 左对齐(默认值) |
| right | 右对齐 |
| center | 居中对齐 |

### 装饰文本

**text-decoration**属性规定添加到文本的修饰.可以给文本添加下划线,删除线,上划线等.

``` css
div {
    text-decoration: underline;
}
```

| 属性值 | 描述 |
| --- | --- |
| none | 默认.没有装饰线(最常用) |
| underline | 下划线.链接a自带下划线(常用) |
| overline | 上划线.(几乎不用) |
| line-through | 删除线.(不常用) |

### 文本缩进

**text-indent**属性用来指定文本的第一行的缩进,通常是将**段落的首行缩进**

``` css
div {
    text-indent: 10px;
}
```

通过设置该属性,所有元素的第一行都可以缩进一个给定的长度,甚至该长度可以是负值.

``` css
p {
    text-indent: 2em;
}
```

**em**是一个相对单位,就是当前元素(font-size)**1个文字的大小**,如果当前元素没有设置大小,则会按照父元素的1个文字大小.

### 行间距

**line-height**属性用于设置行间的距离(行高).可以控制文字间与行间的距离.

``` css
p {
    line-height: 26px;
}
```

### 文本属性总结

| 属性 | 表示 | 注意点 |
| --- | --- | --- |
| color | 文本颜色 | 通常用十六进制而且是简写形式比如#fff |
| text-align | 文本对齐 | 可以设定文字水平的对齐方式 |
| text-indent | 文本缩进 | 通常用于段落首行缩进2个字的距离 text-align: 2em; |
| text-decoration | 文本修饰 | 添加下划线underline取消下划线none |
| line-height | 行高 | 控制行与行之间的距离 |

## CSS引入方式

### CSS的三种样式表

按照CSS样式书写的位置(或者引入的方式),CSS样式表可以分为三大类:

1. 行内样式表(行内式)
2. 内部样式表(嵌入式)
3. 外部样式表(链接式)

#### 内部样式表

内部样式表(内嵌样式表)是写到html页面内部.是将所有的CSS代码抽取出来,单独放到一个`<style>`标签中.

``` css
<style>
    div {
        color: red;
        font-size: 12px;
    }
</style>
```

- `style`标签理论上可以放在HTML文档的任何地方,但一般会放在文档的`<head>`标签中
- 通过此种方式,可以方便地控制当前整个页面中的元素样式设置
- 代码结构清晰,但是并没有实现结构与样式完全分离
- 使用内部样式表设定CSS,通常也被称为**嵌入式引入**,这种方式是我们练习时常用的方式

#### 行内样式表

行内样式表(内联样式表)是**在元素标签内部的style属性中设定CSS样式.适合于修改简单的样式.

``` css
<div style="color: red; font-size: 12px;">哈哈哈红红火火恍恍惚惚</div>
```

- style其实就是标签的属性
- 在双引号中间,写法要符合CSS规范
- 可以控制当前的标签设置样式
- 由于书写繁琐,并且没有体现出结构与样式相分离的思想,所以不推荐大量使用,只对当前元素添加简单样式的时候,可以考虑使用
- 使用行内样式表设定CSS,通常也被称为**行内式引入**

#### 外部样式表

实际开发都是外部样式表.适合于样式比较多的情况.核心是:样式单独写到CSS文件中,之后把CSS文件引入到HTML页面中使用.

引入外部样式表分为两步:

1. 新建一个后缀名为.css的样式文件,把所有CSS代码都放入此文件中.
2. 在HTML页面中,使用`<link>`标签引入这个文件.

``` html
<link rel="stylesheet" href="css文件路径">
```

| 属性 | 作用 |
| --- | --- |
| rel | 定义当前文档与被连接文档之间的关系,在这里需要指定为"stylesheet",表示被链接的文档是一个样式表文件. |
| href | 定义所链接外部样式表文件的URL,可以是相对路径,也可以是绝对路径. |

#### CSS引入方式总结

| 样式表 | 优点 | 缺点 | 使用情况 | 控制范围 |
| --- | --- | --- | --- | --- |
| 行内样式表 | 书写方便,权重高 | 结构样式混写 | 较少 | 控制一个标签 |
| 内部样式表 | 部分结构和样式相分离 | 没有彻底分离 | 较多 | 控制一个页面 |
| 外部样式表 | 完全实现结构和样式相分离 | 需要引入 | 最多 | 控制多个页面 |

## Emment语法

Emment语法的前身是Zen coding,它使用缩写来提高html/css的编写速度,VScode内部已经集成该语法.

### 快速生成HTML结构语法

1. 生成标签,直接输入标签名按tab键即可,比如div然后按tab键,就可以生成`<div></div>`
2. 如果想要生成多个相同的标签,加上`*`就可以了,比如`div*3`就可以快速生成3个div
3. 如果有父子级关系的标签,可以用`>`比如`ul>li`就可以了
4. 如果有兄弟关系的标签,用`+`就可以了,比如`div+p`
5. 如果生成带有类名或者id名的,直接写`.demo`或者`#two`tab键就可以了
6. 如果生成的div类名是有顺序的,可以用自增符号`$`
7. 如果想要在内部生成的标签内部写内容可以用{}表示

### 快速生成CSS样式语法

CSS基本采取简写形式即可.

1. 比如`w200`按tab可以生成`width:200px;`
2. 比如`lh26`按tab可以生成`line-height:26px;`

## CSS的复合选择器

在CSS中,可以根据选择器的类型把选择器分为**基础选择器**和**复合选择器**,复合选择器是建立在基础选择器之上,对基本选择器进行组合形成的.

- 复合选择器可以更准确,更高效地选择目标元素(标签)
- 复合选择器是由两个或多个基础选择器,通过不同的方式组合而成的
- 常用的复合选择器包括:后代选择器,子选择器,并集选择器,伪类选择器等

### 后代选择器(重要)

**后代选择器**又称**包含选择器**,可以选择父元素里面子元素.其写法就是把外层标签写在前面,内层标签写在后面,中间用空格分隔.当标签发生嵌套时,内层标签就成为外层标签的后代.

语法:

``` css
元素1 元素2 { 样式声明 }
```

上述语法表示**选择元素1里面的所有元素2**(后代元素).

例如:

``` css
ul li { 样式声明 } /*选择ul里面的所有的li标签元素*/
```

- 元素1和原宿2中间用**空格隔开**
- 元素1是父级,元素2是子级,最终选择的是**元素2**
- 元素2可以是儿子,也可以是孙子等,只要是元素1的后代即可
- 元素1和元素2可以是任意基础选择器

### 子选择器(重要)

**子元素选择器(子选择器)** 只能选择作为某元素的最近一级子元素.

语法:

``` css
元素1 > 元素2 { 样式声明 }
```

上述语法表示**选择元素1里面的所有直接后代(子元素)元素2**

例如:

``` css
div > p { 样式声明 } /*选择div里面所有最近一级p标签元素*/
```

- 元素1和元素2中间用`>`隔开
- 元素1是父级,元素2是子级,**最终选择的是元素2**
- 元素2必须是**亲儿子**,其孙子,重孙之类都不归他管.

### 并集选择器(重要)

**并集选择器可以选择多组标签,同时为他们定义相同的样式**.通常用于集体声明.
**并集选择器**是各选择器**通过英文逗号(,)链接而成**,任何形式的选择器都可以作为并集选择器的一部分.

语法:

``` css
元素1, 元素2 { 样式声明 }
```

上述语法表示**选择元素1和元素2**.

例如:

``` css
ul, div { 样式声明 } /*选择ul和div标签元素*/
```

- 元素1和元素2中间用**逗号隔开**
- 逗号可以理解为**和**的意思
- 并集选择器通常用于集体声明

### 伪类选择器

**伪类选择器**用于向某些选择器添加特殊的效果,比如给链接添加特殊效果,或者选择第1个,第n个元素.
伪类选择器书写最大的特点是**用冒号(:)表示**,比如`:hover`,`:first-child`.

#### 链接伪类选择器

``` css
a:link /*选择所有未被访问的链接*/
a:visited /*选择所有已被访问的链接*/
a:hover /*选择鼠标指针位于其上的链接*/
a:active /*选择活动链接(鼠标按下未弹起的链接)*/
```

##### 链接伪类选择器注意事项

1. 为了确保生效,请按照**LVHA**的顺序声明:`:link :visited :hover :active`.
2. 因为a链接在浏览器中具有默认样式,所以我们在实际工作中都需要给链接单独指定样式.

#### focus伪类选择器

**focus伪类选择器**用于选取获得焦点的表单元素.

焦点就是光标,一般情况`<input>`类表单元素才能获取,因此这个选择器也主要针对表单元素.

``` css
input:focus {
    background-color: yellow;
}
```

### 复合选择器总结

| 选择器 | 作用 | 特征 | 使用情况 | 隔开符号及用法 |
| --- | --- | --- | --- | --- |
| 后代选择器 | 用来选择后代元素 | 可以是子孙后代 | 较多 | 符号是**空格** .nav a |
| 子代选择器 | 选择最近一级元素 | 只能是子代 | 较少 | 符号是**大于** .nav>p |
| 并集选择器 | 选择某些相同样式的元素 | 可以用于集体声明 | 较多 | 符号是**逗号** .nav, .header |
| 链接伪类选择器 | 选择不同状态的链接 | 跟链接相关 | 较多 | 重点记住a{}和a:hover 实际开发的写法 |
| :focus选择器 | 选择获得光标的表单 | 跟表单相关 | 较少 | input:focus 记住这个写法 |

## CSS的元素显示模式

作用:网页的标签非常多,在不同地方会用到不同类型的标签,了解他们的特点**可以更好的布局网页**

元素显示模式就是**元素(标签)以什么方式进行显示**,比如`<div>`独占一行,比如一行可以放多个`<span>`.

HTML元素一般分为**块元素**和**行内元素**两种类型.

### 块元素

常见的块元素有`<h1>`~`<h6>`,`<p>`,`<div>`,`<ul>`,`<ol>`,`<li>`等,其中`<div>`**标签是最典型的块元素**.

块级元素的特点:

1. 独占一行.
2. 高度,宽度,外边距和内边距都可以控制.
3. 宽度默认是容器(父级宽度)的100%.
4. 是一个容器及盒子,里面可以放行内或者块级元素.

注意:

- 文字类元素内不能使用块级元素
- `<p>`标签主要用于存放文字,因此`<p>`里面不能放块级元素,特别是不能放`<div>`
- 同理,`<h1>`~`<h6>`等都是文字类的块级标签,里面也不能放其他块级元素

### 行内元素

常见的行内元素有`<a>`,`<strong>`,`<b>`,`<em>`,`<i>`,`<del>`,`<s>`,`<ins>`,`<u>`,`<span>`等,其中`<span>`标签是**最典型的行内元素**.有的地方也将行内元素成为**内联元素**.

行内元素的特点:

1. 相邻行内元素在一行上,一行可以显示多个.
2. 高,宽,直接设置是无效的.
3. 默认宽度就是它本身内容的宽度.
4. 行内元素只能容纳文本或其他行内元素.

注意:

- 链接里面不能再放链接
- 特殊情况链接`<a>`里面可以放块级元素,但是给`<a>`转换一下块级模式最安全

### 行内块元素

在行内元素中有几个特殊的标签:`<img />`,`<input />`,`<td>`.它们**同时具有块元素和行内元素的特点**.
有些资料称它们为**行内块元素**.

行内块元素的特点:

1. 和相邻行内元素(行内块)在一行上,但是他们之间会有空白缝隙.一行可以显示多个(行内元素特点).
2. 默认宽度就是它本身内容的宽度(行内元素特点).
3. 高度,行高,外边距以及内边距都可以控制(块级元素特点).

### 元素显示模式总结

| 元素模式 | 元素排列 | 设置样式 | 默认宽度 | 包含 |
| --- | --- | --- | --- | --- |
| 块级元素 | 一行只能放一个块级元素 | 可以设置宽度高度 | 容器的100% | 容器级可以包含任何标签 |
| 行内元素 | 一行可以放多个行内元素 | 不可以直接设置宽度高度 | 它本身内容的宽度 | 容纳文本或者其他行内元素 |
| 行内元素 | 一行放多个行内块元素 | 可以设置宽度和高度 | 它本身内容的宽度 | |

### 元素显示模式转换

特殊情况下,我们需要元素模式的转换,简单理解:一个模式的元素需要另外一种模式的特性
比如想要增加链接`<a>`的触发范围.

- 转换为块元素:display:block;
- 转换为行内元素:display:inline;
- 转换为行内块元素:display:inline-block;

### 单行文字垂直居中的原理

简单理解:行高的上空隙和下空隙把文字挤到中间了,如果行高小于盒子高度,文字会偏上,如果行高大于盒子高度,则文字偏下.

## CSS的背景

通过CSS背景属性,可以给页面元素添加背景样式.
背景属性可以设置背景颜色,背景图片,背景平铺,背景图片位置,背景图像固定等.

### 背景颜色

**background-color**属性定义了元素的背景颜色

``` css
background-color: 颜色值;
```

一般情况下元素背景颜色默认值是**transparent**(透明),我们也可以手动指定背景颜色为透明色.

### 背景图片

**background-image**属性描述了元素的背景图像.实际开发常见于logo或者一些装饰性的小图片或者是超大的背景图片,优点是非常便于控制位置.(精灵图也是一种运用场景)

``` css
background-image: none | url (url)
```

| 参数值 | 作用 |
| --- | --- |
| none | 无背景图(默认的) |
| url | 使用绝对或相对地址指定背景图像 |

### 背景平铺

如果需要在HTML页面上对背景图像进行平铺,可以使用**background-repeat**属性.

``` css
background-repeat: repeat | no-repeat | repeat-x | repeat-y
```

| 参数值 | 作用 |
| --- | --- |
| repeat | 背景图像在纵向和横向上平铺(默认的) |
| no-repeat | 背景图像不平铺 |
| repeat-x | 背景图像在横向上平铺 |
| repeat-y | 背景图像在纵向平铺 |

页面元素既可以添加背景颜色也可以添加背景图片,只不过背景图片会压住背景颜色.

### 背景图片位置

利用**background-position**属性可以改变图片在背景中的位置.

``` css
background-position: x y;
```

参数代表的意思是:x坐标和y坐标.可以使用**方位名词**或者**精确单位**.

| 参数值 | 说明 |
| --- | --- |
| length | 百分数  由浮点数字和单位标识符组成的长度值 |
| position | top  center  bottom  left  right 方位名词 |

1. 参数是方位名词

   - 如果指定的两个值都是方位名词,则两个值前后顺序无关,比如left top和top left效果一致
   - 如果只指定了一个方位名词,另一个值省略,则第二个值默认居中对齐

2. 参数是精确单位

   - 如果参数值是精确坐标,那么第一个肯定是x坐标,第二个一定是y坐标
   - 如果只指定一个数值,那该数值一定是x坐标,另一个默认垂直居中

3. 参数是混合单位

   - 如果指定的两个值是精确单位和方位名词混合使用,则第一个值是x坐标,第二个值是y坐标

### 背景图像固定(背景附着)

**background-attachment**属性设置背景图像是否固定或者随着页面的其余部分滚动.
background-attachment后期可以制作视差滚动的效果.

``` css
background-attachment: scroll | fixed
```

| 参数 | 作用 |
| --- | --- |
| scroll | 背景图像随对象内容滚动 |
| fixed | 背景图像固定 |

### 背景复合写法

为了简化背景属性的代码,我们可以将这些属性合并简写在同一个属性**background**中,从而节约代码量.

当使用简写属性时,没有特定的书写顺序,一般习惯约定顺序为:

**background:背景颜色 背景图片地址 背景平铺 背景图像滚动 背景图片位置;**

``` css
background: transparent url(image.jpg) repeat-y fixed top;
```

这是实际开发中更提倡的写法.

### 背景色半透明

CSS3提供了背景色半透明的效果.

``` css
background: rgba(0, 0, 0, 0.3);
```

- 最后一个参数是alpha透明度,取值范围在0~1之间.
- 我们习惯把0.3的0省略掉,写为background: rgba(0, 0, 0, .3);
- 注意:背景半透明是指盒子背景半透明,盒子里面的内容不受影响
- CSS3新增属性,是IE9+版本浏览器才支持的

### 背景总结

| 属性 | 作用 | 值 |
| --- | --- | --- |
| background-color | 背景颜色 | 预定义的颜色值/十六进制/RGB代码 |
| background-image | 背景图片 | url(图片路径) |
| background-repeat | 是否平铺 | repeat/no-repeat/repeat-x/repeat-y |
| background-position | 背景位置 | length/position 分别是x和y坐标 |
| background-attachment | 背景附着 | scroll(背景滚动)/fixed(背景固定) |
| 背景简写 | 书写更简单 | 背景颜色 背景图片地址 背景平铺 背景滚动 背景位置; |
| 背景色半透明 | 背景色半透明 | background: rgba(0,0,0,0.3); 后面必须是四个值 |

背景图片:实际开发常见于logo或者一些装饰性的小图片或者是超大的背景图片,优点是非常便于控制位置.(精灵图也是一种应用场景)

## CSS的三大特性

CSS有三个非常重要的特性:层叠性,继承性,优先级.

### 层叠性

相同选择器给设置相同的样式,此时一个样式就会**覆盖(层叠)** 另一个冲突的样式.层叠性主要解决样式冲突的问题.

层叠性原则:

- 样式冲突,后面的样式会覆盖前面的样式
- 样式不冲突,不会层叠

### 继承性

CSS中的继承:子标签会继承父标签的某些样式,如文本颜色和字号.

- 恰当地使用继承可以简化代码,降低CSS样式的复杂性
- 子元素可以继承父元素的样式(text-, font-, line-这些元素开头的可以继承,以及color属性)

#### 行高的继承性

``` css
body {
    font:12px/1.5 Microsoft YaHei;
    /*这个1.5就是当前元素文字大小的1.5倍*/
}
```

- 行高可以跟单位也可以不跟单位
- 如果子元素没有设置行高,则会继承父元素的行高
- body行高1.5 这种写法的最大优势就是里面的子元素可以根据自己的文字大小自动调整行高

### 优先级

当同一个元素指定多个选择器,就会有优先级的产生

- 选择器相同,则执行层叠性
- 选择器不同,则根据**选择器权重**执行

选择器权重如下表所示

| 选择器 | 选择器权重 |
| --- | --- |
| 继承 或者 * | 0,0,0,0 |
| 元素选择器 | 0,0,0,1 |
| 类选择器, 伪类选择器 | 0,0,1,0 |
| ID选择器 | 0,1,0,0 |
| 行内样式 style="" | 1,0,0,0 |
| !important 重要的 | 无穷大 |

**优先级注意点:**

1. 权重是有4组数字组成的,但是不会有进位
2. 可以理解为类选择器永远大于元素选择器,id选择器永远大于类选择器,以此类推
3. 等级判断从左向右,如果某一位数值相同,则判断下一位数值
4. **继承的权重是0**,如果该元素没有直接选中,不管父元素权重多高,子元素得到的权重都是0

**权重叠加:** 如果是复合选择器,则会有权重叠加,需要计算权重

## 盒子模型

页面布局要学习三大核心:盒子模型,浮动和定位.学习好盒子模型能非常好的帮助我们布局页面

### 网页布局的本质

网页布局过程:

1. 先准备好先关的网页元素,网页元素基本都是盒子box
2. 利用CSS设置好盒子样式,然后摆放到相应的位置
3. 往盒子里面装内容

网页布局的核心本质:利用CSS摆盒子

### 盒子模型(box model)组成

所谓**盒子模型**:就是把HTML页面中的布局与安苏看作是一个矩形的盒子,也就是一个装内容的容器
CSS盒子模型本质上是一个盒子,封装周围的HTML元素,它包括:边框,外边距,内边距,和实际内容

### 边框(border)

border可以设置元素的边框.边框有三部分组成:边框宽度(粗细)边框样式,边框颜色
CSS边框属性允许你指定一个元素边框的**样式**和**颜色**

语法:

``` css
border: border-width || border-style || border-color
```

| 属性 | 作用 |
| --- | --- |
| border-width | 定义边框粗细,单位是px |
| border-style | 边框的样式 |
| border-color | 边框颜色 |

边框简写:

``` css
border: 1px solid red;  /*没有顺序*/
```

边框分开写:

``` css
border-top: 1px solid red; /*只设定上边框,其余同理*/
```

#### 表格的细线边框

**border-collapse**属性控制浏览器绘制表格边框的方式.它控制相邻单元格的边框.

语法:

``` css
border-collapse: collapse;
```

- collapse的意思是合并
- border-collapse: collapse;表示相邻边框合并在一起

#### 边框会影响盒子实际大小

边框会额外增加盒子的实际大小.因此有两种方案解决:

1. 测量盒子大小的时候,不量边框
2. 如果测量的时候包含了边框,则需要width/height减去边框宽度

### 内边距(padding)

**padding**属性用于设置内边距,即边框与内容之间的距离

| 属性 | 作用 |
| --- | --- |
| padding-left | 左内边距 |
| padding-right | 右内边距 |
| padding-top | 上内边距 |
| padding-bottom | 下内边距 |

**padding**属性(简写属性)可以有一到四个值

| 值的个数 | 表达意思 |
| --- | --- |
| padding: 5px; | 1个值,代表上下左右都有5像素内边距 |
| padding: 5px 10px; | 2个值,代表上下内边距是5像素,左右内边距是10像素 |
| padding: 5px 10px 20px; | 3个值,代表上内边距5像素,左右内边距10像素,下内边距20像素 |
| padding: 5px 10px 20px 30px; | 4个值,上5像素,右10像素,下20像素,左30像素 |

当我们给盒子指定**padding**值之后,发生了2件事情:

1. 内容和边框有了距离,添加了内边距
2. padding影响盒子的实际大小

也就是说,如果盒子已经有了宽度和高度,此时再指定内边框,会撑大盒子
如果盒子本身没有指定width/height属性,则此时padding不会撑开盒子大小

解决方案:

如果保证盒子跟效果图大小保持一致,则让**width/height减去多出来的内边距大小**即可

### 外边距(margin)

**margin**属性用于设置外边距,即控制盒子和盒子之间的距离

| 属性 | 作用 |
| --- | ---|
| margin-left | 左外边距 |
| margin-right | 右外边距 |
| margin-top | 上外边距 |
| margin-bottom | 下外边距 |

margin简写方式代表的意义跟padding完全一致

#### 外边距典型应用

外边距可以让块级盒子**水平居中**,但是必须满足两个条件:

1. 盒子必须指定了宽度(width)
2. 盒子**左右的外边距都设置为auto**

``` css
.header { width:960px; margin:0 auto; }
```

常见的写法,以下三种都可以:

- margin-left:auto; margin-right:auto;
- margin:auto;
- margin: 0 auto;

注意:以上方法是让块级元素水平居中,**行内元素或者行内块元素水平居中给其父元素添加text-align:center即可**

#### 外边距合并

使用**margin**定义块元素的**垂直外边距**时,可能会出现外边距的合并

##### 相邻块元素垂直外边距的合并

当上下相邻的两个块元素(兄弟关系)相遇时,如果上面的元素有下外边距margin-bottom,下面的元素有上外边距margin-top,则他们之间的垂直间距不是margin-bottom与margin-top之和.**取两个值中的较大者这种现象称为相邻块元素垂直外边距的合并**

解决方案:
尽量只给一个盒子添加margin值

##### 嵌套块元素垂直外边距的塌陷

对于两个嵌套关系(父子关系)的块元素,父元素有上外边距同时子元素也有上外边距,此时父元素会塌陷较大的外边距值

解决方案:

1. 可以为父元素定义上边框
2. 可以为父元素定义上内边距
3. 可以为父元素添加overflow:hidden;

### 清除内外边距

网页元素很多都带有默认的内外边距,而且不同浏览器默认的也不一样.因此在布局前,首先要清除网页元素的内外边距.

``` css
* {
    padding: 0; /*清除内边距*/
    margin: 0; /*清除外边距*/
}
```

注意:行内元素为了照顾兼容性,尽量只设置左右内外边距,不要设置上下内外边距.但是转换为块级和行内元素就可以了.

## 圆角边框

在CSS3中,新增了**圆角边框**样式,这样我们的盒子就可以变成圆角了.

语法:

``` css
border-radius: length;
```

**radius半径(圆的半径)原理:** (椭)圆与边框的交集形成的圆角效果.

- 参数值可为**数值**或**百分比**的形式
- 如果是**正方形**,想要设置为一个圆,把数值修改为**高度或宽度的一半**即可,或者直接写为**50%**
- 如果是矩形,设置为高度的一半就可以了
- 该属性是一个**简写属性**,可以跟四个值,分别代表**左上角,右上角,右下角,左下角**

## 盒子阴影

CSS3中新增了盒子阴影,我们可以使用**box-shadow**属性为盒子添加阴影

语法:

``` css
box-shadow: h-shadow v-shadow blur spread color inset;
```

| 值 | 描述 |
| --- | --- |
| h-shadow | 必需.水平阴影的位置.允许负值. |
| v-shadow | 必需.垂直阴影的位置.允许负值. |
| blur | 可选.模糊距离. |
| spread | 可选.阴影的尺寸. |
| color | 可选.阴影的颜色.请参阅CSS颜色值. |
| inset | 可选.将外部阴影(outset)改为内部阴影. |

注意:

1. 默认的是外阴影(outset),但是不可以写这个单词,否则导致阴影无效
2. 盒子阴影不占空间,不会影响其他盒子排列

## 文字阴影

在CSS3中,我们可以使用**text-shadow**属性将阴影应用于文本

语法:

``` css
text-shadow: h-shadow v-shadow blur color;
```

| 值 | 描述 |
| --- | --- |
| h-shadow | 必需,水平阴影的位置.允许负值. |
| v-shadow | 必需,垂直阴影的位置.允许负值. |
| blur | 可选.模糊的距离. |
| color | 可选.阴影的颜色.参阅CSS颜色值. |

## 浮动(float)

### 传统网页布局的三种方式

CSS提供了三种传统布局方式(简单说,就是盒子如何进行排列):

- 普通流(标准流)
- 浮动
- 定位

#### 标准流(普通流/文档流)

**所谓标准流:就是标签按照规定好的默认方式排列.**

1. 块级元素会独占一行,从上向下顺序排列.
2. 行内元素会按照顺序,从左到右排列,碰到父元素边缘则自动换行.

以上都是标准流布局,**标准流是最基本的布局方式**.

这三种布局方式都是用来摆放盒子的,盒子摆放到合适位置,布局自然就完成了.

**注意:实际开发中,一个页面基本都包含了这三种布局方式.**

### 为什么需要浮动

有很多的布局效果,标准流没有办法完成,此时就可以利用浮动完成布局.因为浮动可以改变元素标签默认的排列方式.

浮动最典型的应用:可以让多个块级元素一行内排列显示.
网页布局第一原则:**多个块级元素纵向排列找标准流,多个块级元素横向排列找浮动**.

### 什么是浮动

**float**属性用于创建浮动框,将其移动到一边,直到左边缘或右边缘触及包含块或者另一个浮动框的边缘.

语法:

``` css
选择器 {
    float: 属性值;
}
```

| 属性值 | 描述 |
| --- | --- |
| none | 元素不浮动(默认值) |
| left | 元素向左浮动 |
| right | 元素向右浮动 |

#### 浮动特性(重难点)

加了浮动之后的元素会具有很多特性.

1. 浮动元素会脱离标准流(脱标)
2. 浮动的元素会一行内显示并且元素顶部对齐
3. 浮动的元素会具有行内块元素的特性
4. 浮动的盒子**不再保留原先位置**

**注意:浮动的元素是互相贴靠在一起的(不会有缝隙),如果父级宽度装不下这些浮动的盒子,多出的盒子会另起一行对齐.**

- 如果块级盒子没有设置宽度,默认宽度和父级一样宽,但是添加浮动后,它的大小根据内容来决定
- 浮动的盒子中间没有空隙,是紧挨在一起的
- 行内元素同理

#### 浮动元素经常和标准流父级搭配使用

为了约束浮动元素的位置,我们网页布局一般采取的策略是:

**先用标准流的父元素排列上下位置,之后内部子元素采用浮动排列左右位置.符合网页布局第一准则.**

#### 浮动布局注意点

1. 浮动和标准流父盒子搭配.
    先用标准流的父元素排列上下位置,之后内部子元素采取浮动排列左右位置.
2. 一个元素浮动了理论上其余的兄弟元素也要浮动.
    一个盒子里有多个盒子,如果其中一个浮动了,那么其他兄弟也应该浮动,以防止引起问题.
    浮动盒子只会影响浮动盒子后面的标准流,不会影响前面的标准流.

#### 清除浮动

##### 为什么要清除浮动

由于父级盒子很多情况下,不方便给高度,但是子盒子浮动又不占位置,最后父级盒子高度为0时,就会影响下面的标准流盒子.

- 由于浮动元素不再占用原文档流的位置,所以它会对后面的元素排版产生影响.

##### 清除浮动的本质

- 清除浮动的本质是清除浮动元素造成的影响
- 如果父盒子本身有高度,则不需要清除浮动
- 清除浮动之后,父级就会根据浮动的子盒子自动检测高度.父级有了高度,就不会影响下面的标准流了

语法:

``` css
选择器 {clear: 属性值;}
```

| 属性值 | 描述 |
| --- | --- |
| left | 不允许左侧有浮动元素(清除左侧浮动元素造成的影响) |
| right | 不允许右侧有浮动元素(清除右侧浮动元素造成的影响) |
| both | 同时清除左右两侧浮动的影响 |

实际工作中,几乎只用**clear:both;**
**清除浮动的策略是:闭合浮动**

##### 清除浮动方法

1. **额外标签法**也称为隔墙法,是W3C推荐的做法.
2. 父级添加overflow属性
3. 父级添加after伪元素
4. 父级添加双伪元素

###### 清除浮动:额外标签法

**额外标签法**也称为**隔墙法**,是W3C推荐的做法.
**额外标签法**会在浮动元素末尾添加一个空的标签.例如`<div style="clear:both"></div>`,或者其他标签(`<br />`等).

- 优点:通俗易懂,书写方便
- 缺点:添加许多无意义的标签,结构化较差

注意这个新的空标签必须是块级元素

###### 清除浮动:父级添加 overflow

可以给父级添加**overflow**属性,将其属性设置为**hidden,auto或scroll**

- 优点:代码简洁
- 缺点:无法显示溢出部分

###### 清除浮动: :after伪元素法

*:after*方式是额外标签法的升级版.也是给父元素添加

``` css
.clearfix:after {
    content: "";
    display: block;
    height: 0;
    clear: both;
    visibility: hidden;
}

.clearfix { /*IE6, 7专有*/
    *zoom: 1;
}
```

- 优点:没有增加标签,结构更简单
- 缺点:需要照顾低版本浏览器

###### 双伪元素清除浮动

``` css
.clearfix:before,.clearfix:after {
    content:"";
    display:table;
}

.clearfix:after {
    clear:both;
}

.clearfix {
    *zoom:1;
}
```

- 优点:代码更简洁
- 缺点:需要照顾低版本浏览器

##### 清除浮动总结

为什么需要清除浮动?

1. 父级没高度了
2. 子盒子浮动了
3. 影响下面布局了,我们就应该清除浮动了

| 清除浮动的方式 | 优点 | 缺点 |
| --- | --- | --- |
| 额外标签法(隔墙法) | 通俗易懂,书写方便 | 添加许多无意义标签,结构化较差 |
| 父级overflow:hidden; | 书写简单 | 溢出隐藏 |
| 父级after伪元素 | 结构化语义化正确 | 由于IE6-7不支持:after,兼容性问题 |
| 父级双伪元素 | 结构语义化正确 | 由于IE6-7不支持:after,兼容性问题 |

## 页面布局整体思路

为了提高网页制作的效率,布局时通常采取以下的整体思路:

1. 必需确定页面的版心(可视区),我们测量可得知.
2. 分析页面中的行模块,以及每个行模块中的列模块.其实就是页面布局第一准则.
3. 一行中的列模块经常浮动布局,先确定每个列的大小,之后确定列的位置.是页面布局第二准则.
4. 制作HTML结构.我们遵循先有结构,后有样式的原则.结构永远最重要.
5. 所以先理清楚**布局结构**,再写代码尤为重要.这需要我们多写多积累.

### 头部制作

导航栏注意点:

**实际开发中,我们不会直接用链接a而是用li包含链接(li+a)的做法.**

1. li+a语义更清晰,一看这就是有条理的列表型内容.
2. 如果直接用a,搜索引擎容易辨别为有堆砌关键字的嫌疑(故意堆砌关键字有被搜索引擎降权的风险)从而影响网站排名.

注意:

1. 让导航栏一行显示,给li加浮动,因为li是块级元素,需要一行显示.
2. nav导航栏可以不给宽度,将来可以继续添加文字.
3. 因为导航栏里面文字不一样多,所以最好给链接a左右padding撑开盒子,而不是指定宽度.

## 定位

### 为什么需要定位

1. 浮动可以让多个块级盒子一行没有缝隙排列显示,经常用于横向排列盒子.
2. 定位则是可以让盒子自由的在某个盒子内移动位置或者固定在屏幕中某个位置,并且可以压住其他盒子.

### 定位组成

**定位**:将盒子定在某一个位置,所以**定位也是摆在摆放盒子,按照定位的方式移动盒子**

定位 = 定位模式 + 边偏移

**定位模式**用于指定一个元素在文档中的定位方式.**边偏移**则决定了该元素的最终位置.

#### 定位模式

定位模式决定元素的定位方式,它通过CSS的**position**属性来设置,其值可以分为四个:

| 值 | 语义 |
| --- | --- |
| `static` | 静态定位 |
| `relative` | 相对定位 |
| `absolute` | 绝对定位 |
| `fixed` | 固定定位 |

#### 边偏移

边偏移就是定位的盒子移动到最终位置.有top,bottom,left和right 4个属性

| 边偏移属性 | 示例 | 描述 |
| --- | --- | --- |
| `top` | `top: 80px` | **顶端**偏移量,定义元素相对于其父元素**上边线的距离** |
| `bottom` | `bottom: 80px` | **底部**偏移量,定义元素相对于其父元素**下边线的距离** | 
| `left` | `left: 80px` | **左侧**偏移量,定义元素相对于其父元素**左边线的距离** |
| `right` | `right: 80px` | **右侧偏移量**,定义元素相对于其父元素**右边线的距离** |

##### static静态定位(理解)

静态定位就是元素的**默认定位方式**,**无定位的意思**

语法:

``` css
选择器 { position: static; }
```

- 静态定位按照标准流特性摆放位置,它没有偏移
- 静态定位在布局时很少用到

##### 相对定位 relative(重要)

**相对定位**是元素在移动位置的时候,是相对于它**原来的位置**来说的

语法:

``` css
选择器 { position: relative; }
```

相对定位的特点:(务必记住)

1. 它是相对于自己原来的位置来移动的.(**移动位置的时候参照点是自己原来的位置**)
2. 原来在标准流的**位置**继续占有,后面的盒子仍然以标准流的方式对待它.(**不脱标,继续保留原来的位置**)

##### 绝对定位absolute(重要)

**绝对定位**是元素在移动位置的时候,是相对于它的**祖先元素**来说的.

语法:

``` css
选择器 { posiiton: absolute; }
```

绝对定位的特点:(务必记住)

1. 如果**没有祖先元素**或者**祖先元素没有定位**,则以浏览器为准定位(Document文档)
2. 如果祖先元素有定位(相对,绝对,固定定位),则以最近一级的有定位祖先元素为参考点移动位置.
3. 绝对定位**不再占有原来的位置**.(脱标)

##### 子绝父相的由来

这句话的意思是:**子级是绝对定位的话,父级要用相对定位**

1. 子级绝对定位,不会占有位置,可以放到父盒子里面的任何一个地方,不会影响其他的兄弟盒子.
2. 父盒子需要加定位限制盒子在父盒子内显示.
3. 父盒子布局时,需要占有位置,因此父亲只能是相对定位.

这就是子绝父相的由来,所以**相对定位经常用来作为绝对定位的父级**.

总结:**因为父级需要占有位置,因此就是相对定位,子盒子不需要占有位置,则是绝对定位**

当然,子绝父相不是永远不变的,如果父元素不需要占有位置,**子绝父绝**也会遇到.

##### 固定定位fixed(重要)

**固定定位**是元素**固定于浏览器可视区域的位置**.主要使用场景:可以在浏览器页面滚动时元素的位置不变.

语法:

``` css
选择器 { position: fixed; }
```

固定定位特点:(务必记住)

1. 以浏览器的可视窗口为参照点移动元素.
2. 固定定位**不占用原先的位置**.

固定定位也是脱标的,其实固定定位可以看成是一种特殊的绝对定位.

##### 固定定位小技巧:固定在版心右侧位置

小算法:

1. 让固定定位的盒子left:50%,走到浏览器可视区(也可以看做版心)的一半位置.
2. 让固定定位的盒子margin-left:版心宽度的一半距离.多走版心宽度的一半位置.

##### 粘性定位sticky(了解)

**粘性定位**可以被认为是相对定位和固定定位的组合.sticky(粘性的)

语法:

``` css
选择器 { position: sticky; top: 10px; }
```

粘性定位的特点:

1. 以浏览器的可视窗口为参照点移动元素(固定定位特点)
2. 粘性定位**占有原先的位置**(相对定位特点)
3. 必须添加top,left,right,bottom其中一个才有效
4. 跟页面滚动搭配使用.兼容性较差,IE不支持

### 定位的总结

| 定位模式 | 是否脱标 | 移动位置 | 是否常用 |
| --- | --- | --- | --- |
| static静态定位 | 否 | 不能使用边偏移 | 很少 |
| relative相对定位 | 否(占用位置) | 相对于自身位置移动 | 常用 |
| absolute绝对定位 | 是(不占用位置) | 带有定位的父级 | 常用 |
| fixed固定定位 | 是(不占用位置) | 浏览器可视区 | 常用 |
| sticky粘性定位 | 否(占用位置) | 浏览器可视区 | 较少 |

1. 一定记住相对定位,固定定位,绝对定位的两个特点:是否占有位置(脱标).以谁为基准点移动位置.
2. 学习定位重点学会子绝父相.

### 定位叠放次序 z-index

在使用定位布局时,可能会出现盒子重叠的情况.此时,可以使用**z-index**来控制盒子的前后次序(z轴)

语法:

``` css
选择器 { z-index: 1; }
```

- 数值可以是正整数,负整数,或0,默认是auto,数值越大,盒子越靠上
- 如果属性值相同,则按照书写顺序,后来居上
- 数字后面不能加单位
- 只有定位的盒子才有z-index属性

### 定位的拓展

1. 绝对定位的盒子居中

    加了绝对定位的盒子不能通过`margin: 0 auto;`水平居中,但是可以通过以下计算方法实现水平和垂直居中.

    - `left: 50%;`让盒子左侧移动到父级元素的水平中心位置.
    - `margin-left: -(自身宽度的一半)px;`让盒子向左移动自身宽度的一半.

2. 定位特殊特性

    绝对定位和固定定位也和浮动类似.

    - 行内元素添加绝对定位或者固定定位,可以直接设定高度和宽度.
    - 块级元素添加绝对或相对定位,如果不给宽度或者高度,默认大小是内容大小.

3. 脱标的盒子不会触发外边距塌陷

    浮动元素,绝对定位(固定定位)的元素都不会触发外边距合并的问题.

4. 绝对定位(固定定位)会完全压住盒子

    浮动元素不同,只会压住它下面的标准流的盒子,但是不会压住下面标准流盒子里面的文字(图片).

    但是绝对定位(固定定位)会压住下面标准流所有的内容.

    浮动之所以不会压住文字,是因为浮动产生的目的是为了做文字环绕效果的.文字会围绕浮动元素.

### 网页布局总结

通过盒子模型,清楚知道大部分html标签是一个盒子.

通过CSS浮动,定位可以让每个盒子排列成为网页.

一个完整的网页,是标准流,浮动,定位一起完成布局的,每个都有自己的专门用法.

1. 标准流

    可以让盒子上下排列或者左右排列,**垂直的块级盒子显示就用标准流布局.**

2. 浮动

    可以让多个块级元素一行显示或者左右对齐盒子,**多个块级盒子水平显示就用浮动布局.**

3. 定位

    定位最大特点是有层叠的概念,就是可以让多个盒子前后叠压来显示.**如果元素自由在某个盒子内移动就用定位布局.**